"""
This module handles creation of local JSON databases for non-NCBI lookups.
"""


import re
import json
import logging
import subprocess

from pathlib import Path

from collections import defaultdict, namedtuple

from clusterblaster import helpers

LOG = logging.getLogger(__name__)


class Protein:
    """The Protein class is a simple container for Proteins inside a DB instance.

    It provides the following functionality:

        1. Store the entire genomic context of the protein, including position on a
           scaffold and its parent organism/strain
        2. Method for generating unique header containing the proteins lineage, used
           when building the diamond database such that search hits can be traced back
           to the correct Protein instances, even if different organisms have identical
           protein naming schemes
        3. Property for building FASTA str of the protein including its unique header
        4. Method for serialising the instance to dict
    """

    __slots__ = (
        "id",
        "index",
        "sequence",
        "scaffold",
        "start",
        "end",
        "strand",
        "organism",
        "strain",
    )

    def __init__(
        self, id, index, sequence, scaffold, start, end, strand, organism, strain
    ):
        self.id = id
        self.index = index
        self.end = end
        self.start = start
        self.strand = strand
        self.strain = strain
        self.sequence = sequence
        self.scaffold = scaffold
        self.organism = organism

    @property
    def header(self):
        """Generate header for this Protein containing its full lineage."""
        return "{}|{}|{}|{}".format(
            str(self.organism).replace(" ", "_"),
            str(self.strain).replace(" ", "_"),
            self.scaffold,
            self.id,
        )

    @property
    def fasta(self):
        """Generate FASTA format string."""
        return f">{self.header}\n{self.sequence}"

    def to_dict(self):
        """Serialise this Protein instance to dict."""
        return {
            "id": self.id,
            "end": self.end,
            "index": self.index,
            "start": self.start,
            "strand": self.strand,
            "sequence": self.sequence,
        }


class DB:
    """The DB class handles reading/writing of the local JSON database.

    organisms: dict
        Complete hierarchy of objects in the DB instance.
        Organism -> Strain -> Scaffold -> Proteins

    proteins: dict
        Dictionary of proteins keyed on protein IDs.

        To facilitate quicker lookups by protein rather than through organism.
    """

    Organism = namedtuple("Organism", "name strain file scaffolds")
    Scaffold = namedtuple("Scaffold", "accession proteins")

    def __init__(self, db=None):
        self.proteins = {}
        self.organisms = defaultdict(dict)

        if db:
            self._from_db(db)

    def _from_db(self, database):
        """Format parsed JSON GenBank database as DB instance."""
        for organism in database:
            self.add_organism(organism)

    def fasta_iter(self):
        """Generate FASTA format sequence for proteins in this DB instance."""
        for protein in self.proteins.values():
            yield protein.fasta

    def write_fasta(self, handle):
        """Write sequences in this DB instance to file."""
        for fasta in self.fasta_iter():
            print(fasta, file=handle)

    def makedb(self, name):
        """Convenience function to write FASTA and generate diamond DB"""
        with open(f"{name}.faa", "w") as handle:
            self.write_fasta(handle)
        diamond_makedb(f"{name}.faa", name)

    def validate_strain(self, species, strain, allow_duplicates=True):
        """Check a given strain is already in this DB instance.

        If yes, this function will return an altered strain name, appended with the
        current count of duplicate strains already in this DB. Otherwise, the strain
        will be returned unchanged.

        If allow_duplicates=False, a ValueError will be raised.
        """
        if strain in self.organisms[species]:
            if allow_duplicates:
                count = sum(
                    1 if str(strain) in str(prev_strain) else 0
                    for prev_strain in self.organisms[species]
                )
                return f"{strain}_{count}"
            raise ValueError("Found duplicate strain but allow_duplicate_strains=False")
        return strain

    def add_organism(self, organism, allow_duplicate_strains=True):
        """Add an organism dictionary, as generated by parse_genbank()."""

        file = organism["file"]
        species = organism["name"]
        strain = self.validate_strain(
            species, organism["strain"], allow_duplicates=allow_duplicate_strains
        )

        self.organisms[species][strain] = self.Organism(species, strain, file, {})

        for scaffold in organism["scaffolds"]:

            accession = scaffold["accession"]

            # Build ordered list of Protein objects
            _proteins = [
                Protein(
                    protein["id"],
                    protein["index"],
                    protein["sequence"],
                    accession,
                    protein["start"],
                    protein["end"],
                    protein["strand"],
                    species,
                    strain,
                )
                for protein in scaffold["proteins"]
            ]

            # Save them ordered here so we don't have to sort later
            self.organisms[species][strain].scaffolds[accession] = self.Scaffold(
                accession, _proteins
            )

            # Save as dict for quick lookups; should be fine memory-wise since p will
            # just refer to same instances held in self.organisms
            self.proteins.update({p.header: p for p in _proteins})

    @classmethod
    def from_files(cls, files):
        """Build a DB instance from a collection of GenBank files.

        For example:

        >>> db = database.DB.from_files(['path/to/file.gbk', 'path/to/file.gbk'])
        """
        database = cls()

        LOG.info("Parsing %i files...", len(files))
        for index, file in enumerate(files, 1):
            with open(file) as handle:
                LOG.info("%i. %s", index, file)
                database.add_organism(parse_genbank(handle))

        return database

    @classmethod
    def from_json(cls, json_file):
        """Load a DB distance from JSON."""
        with open(json_file) as handle:
            js = json.load(handle)
        return cls(js)

    @staticmethod
    def _org_as_dict(organism):
        """Serialise an Organism namedtuple to dict."""
        return {
            "name": organism.name,
            "strain": organism.strain,
            "file": organism.file,
            "scaffolds": [
                {
                    "accession": scaffold.accession,
                    "proteins": [protein.to_dict() for protein in scaffold.proteins],
                }
                for scaffold in organism.scaffolds.values()
            ],
        }

    def to_list(self):
        """Serialize the DB to list."""
        return [
            self._org_as_dict(organism)
            for name, strains in self.organisms.items()
            for organism in [self.organisms[name][strain] for strain in strains]
        ]

    def to_json(self, handle, indent=None):
        """Serialise to JSON and write to an open file handle."""
        json.dump(self.to_list(), handle, indent=indent)


def parse_genbank(handle):
    r"""Parse Proteins from a GenBank-format file.

    This function uses several regex patterns to extract gene positions. It first
    looks for scaffolds, by looking for blocks that start with LOCUS and end with //;
    each match is iterated.

    Another pattern is used inside each scaffold match to extract the start and end
    position of CDS features, as well as its protein ID and translation. Therefore, a
    minimal valid file should resemble something like:

    .. code-block::

        LOCUS     scaffold_1    ...
        ...
        ORGANISM  Organism name
        ...
        source    1..10000
                  /organism="Organism name"
                  /strain="STRAIN 123"
                  ...
        CDS       complement(join(1..100,200..300))
                  ...
                  /protein_id="Protein1"
                  ...
                  /translation="M..."
        //
        ...

    If no organism or strain information can be identified, they will be set to 'NA',
    and CDS features will be parsed as normal.

    Regular Expressions:
      protein
        r"CDS\s+?"          1. Find start of CDS feature
        r"(.*?)"            2. Save any location modifiers (complement, join)
        r"(\d+?)\.\."       3. Capture start position, e.g. 10..
        r"(?:.+?\.\.)*?"    4. Non-capture group, anything until .. before final
                               number in location. Optional so that simple locations
                               will also be parsed correctly.
        r"[<>]*?"           5. Account for potential truncation symbols
        r"(\d+?)"           6. Capture end position
        r"[<>)]*?"          7. Truncations, end parentheses...
        r"[\n\r]\s+?/"      8. Until next qualifier (starting with '/')
        r"(?:.+?)*?"        9. Optional extra junk if next qualifier isn't identifier

        r'(?:protein_id|locus_tag)="([\w.:-]+?)"'
                           10. Get either locus tag or protein ID, whichever is first
        r".+?"             11. Skip everything until translation
        r'/translation="([A-Z\n\r\s ]+?)"'
                           12. Get translation
    """

    patterns = {
        "scaffold": re.compile(r"LOCUS\s+?(?P<accession>\b[\w.-]+?)\s.+?//", re.DOTALL),
        "organism": re.compile(r"ORGANISM\s+?(?P<organism>\w[\w .-]+?)[\n\r]"),
        "strain": re.compile(r'/strain="(?P<strain>([\w .-]+?))"'),
        "protein": re.compile(
            r"CDS\s+?"
            r"([a-z<>(]*?)"  # join(complement( location modifiers, if any
            r"(\d+?)\.\."  # start
            r"(?:[0-9,.()]+?\.\.)*?"
            r"[<>)]*?"
            r"(\d+?)"  # end
            r"[<>)]*?"
            r"[\n\r]\s+?/"
            "(.*?)"
            r'/translation="([A-Z\n\r\s ]+?)"',  # translation
            re.DOTALL,
        ),
        "identifier": re.compile(r'(protein_id|locus_tag|gene|ID)="([\w.:-]+?)"'),
    }

    raw = handle.read()
    scaffolds = []
    organism, strain = None, None

    for scaffold in patterns["scaffold"].finditer(raw):

        text = scaffold.group(0)
        accession = scaffold.group("accession")

        if not organism:
            try:
                organism = patterns["organism"].search(text).groups()[0]
            except (IndexError, AttributeError):
                pass

        if not strain:
            try:
                strain = patterns["strain"].search(text).groups()[0]
            except (IndexError, AttributeError):
                pass

        proteins = [
            {
                # Coincidentally, reverse alphabetical order is also preferred choice
                # of protein identifier (i.e. protein_id -> locus_tag -> ID -> gene)
                # So, reverse sort and take value of first match tuple
                "id": sorted(patterns["identifier"].findall(gene[3]), reverse=True)[0][
                    1
                ],
                "index": index,
                "start": int(gene[1]),
                "end": int(gene[2]),
                "strand": "-" if "complement" in gene[0] else "+",
                "sequence": gene[-1].replace(" ", "").replace("\n", ""),
            }
            for index, gene in enumerate(patterns["protein"].findall(text))
        ]

        if proteins:
            scaffolds.append({"accession": accession, "proteins": proteins})

    if not organism:
        LOG.warning("Could not find organism, will be set to 'No_organism'")
        organism = "No_organism"

    if not strain:
        LOG.warning("Could not find strain, will be set to 'No_strain'")
        strain = "No_strain"

    return {
        "name": organism,
        "strain": strain,
        "file": handle.name,
        "scaffolds": scaffolds,
    }


def get_genbank_paths(folder):
    """Generate a collection of paths to GenBank files in a specified folder."""
    if not Path(folder).is_dir():
        raise ValueError("Expected valid folder")
    valid_extensions = (".gb", ".gbk", ".genbank")
    return [
        file for file in Path(folder).iterdir() if str(file).endswith(valid_extensions)
    ]


def diamond_makedb(fasta, name):
    """Build DIAMOND database from JSON."""
    diamond = helpers.get_program_path(["diamond", "diamond-aligner"])
    subprocess.run(
        [diamond, "makedb", "--in", fasta, "--db", name],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
