"""
This module handles creation of local JSON databases for non-NCBI lookups.
"""


import re
import sys
import json
import logging
import subprocess

from pathlib import Path

from collections import defaultdict, namedtuple

from clusterblaster import helpers

LOG = logging.getLogger(__name__)


class DB:
    """The DB class handles reading/writing of the local JSON database.

    organisms: dict
        Complete hierarchy of objects in the DB instance.
        Organism -> Strain -> Scaffold -> Proteins

    proteins: dict
        Dictionary of proteins keyed on protein IDs.

        To facilitate quicker lookups by protein rather than through organism.
    """

    Organism = namedtuple("Organism", "name strain file scaffolds")
    Scaffold = namedtuple("Scaffold", "accession proteins")
    Protein = namedtuple(
        "Protein", "id sequence scaffold start end strand organism strain"
    )

    def __init__(self, db=None):
        self.proteins = {}
        self.organisms = defaultdict(dict)

        if db:
            self._from_db(db)

    def _from_db(self, database):
        """Format parsed JSON GenBank database as DB instance."""
        for organism in database:
            self.add_organism(organism)

    def fasta_iter(self):
        """Generate FASTA format sequence for proteins in this DB instance."""
        for protein in self.proteins.values():
            yield f">{protein.id}\n{protein.sequence}\n"

    def write_fasta(self, handle):
        """Write sequences in this DB instance to file."""
        for fasta in self.fasta_iter():
            handle.write(fasta)

    def makedb(self, name):
        """Convenience function to write FASTA and generate diamond DB"""
        with open(f"{name}.faa", "w") as handle:
            self.write_fasta(handle)
        diamond_makedb(f"{name}.faa", name)

    def validate_strain(self, species, strain, allow_duplicates=True):
        """Check a given strain is already in this DB instance.

        If yes, this function will return an altered strain name, appended with the
        current count of duplicate strains already in this DB. Otherwise, the strain
        will be returned unchanged.

        If allow_duplicates=False, a ValueError will be raised.
        """
        if strain in self.organisms[species]:
            if allow_duplicates:
                count = sum(
                    1 if str(strain) in str(prev_strain) else 0
                    for prev_strain in self.organisms[species]
                )
                return f"{strain}_{count}"
            else:
                raise ValueError(
                    "Found duplicate strain but allow_duplicate_strains=False"
                )
        return strain

    def add_organism(self, organism, allow_duplicate_strains=True):
        """Add an organism dictionary, as generated by parse_genbank()."""

        file = organism["file"]
        species = organism["name"] if organism["name"] else "No organism"
        strain = self.validate_strain(
            species, organism["strain"], allow_duplicates=allow_duplicate_strains
        )

        self.organisms[species][strain] = self.Organism(species, strain, file, {})

        for scaffold in organism["scaffolds"]:

            accession = scaffold["accession"]

            # Build ordered list of Protein objects
            _proteins = [
                self.Protein(
                    protein["id"],
                    protein["sequence"],
                    accession,
                    protein["start"],
                    protein["end"],
                    protein["strand"],
                    organism["name"],
                    organism["strain"],
                )
                for protein in scaffold["proteins"]
            ]

            # Save them ordered here so we don't have to sort later
            self.organisms[species][strain].scaffolds[accession] = self.Scaffold(
                accession, _proteins
            )

            # Save as dict for quick lookups; should be fine memory-wise since p will
            # just refer to same namedtuples held in self.organisms
            self.proteins.update({p.id: p for p in _proteins})

    @classmethod
    def from_files(cls, files):
        """Build a DB instance from a collection of GenBank files."""
        database = cls()

        LOG.info("Parsing %i files...", len(files))
        for index, file in enumerate(files, 1):
            with open(file) as handle:
                LOG.info("%i. %s", index, file)
                database.add_organism(parse_genbank(handle))
        return database

    @classmethod
    def from_json(cls, json_file):
        """Load a DB distance from JSON."""
        with open(json_file) as handle:
            js = json.load(handle)
        return cls(js)

    @staticmethod
    def _org_as_dict(organism):
        """Serialise an Organism namedtuple to dict."""

        return {
            "name": organism.name,
            "strain": organism.strain,
            "file": organism.file,
            "scaffolds": [
                {
                    "accession": scaffold.accession,
                    "proteins": [
                        {
                            "id": protein.id,
                            "sequence": protein.sequence,
                            "start": protein.start,
                            "end": protein.end,
                            "strand": protein.strand,
                        }
                        for protein in scaffold.proteins
                    ],
                }
                for scaffold in organism.scaffolds.values()
            ],
        }

    def to_list(self):
        """Serialize the DB to list."""
        return [
            self._org_as_dict(organism)
            for name, strains in self.organisms.items()
            for organism in [self.organisms[name][strain] for strain in strains]
        ]

    def to_json(self, handle, indent=None):
        """Serialise to JSON and write to an open file handle."""
        json.dump(self.to_list(), handle, indent=indent)


def parse_genbank(handle):
    r"""Parse a GenBank-format file for genes.

    This function uses several regex patterns to extract gene positions. It first
    looks for scaffolds, by looking for blocks that start with LOCUS and end with //;
    each match is iterated.

    Another pattern is used inside each scaffold match to extract the start and end
    position of a gene, as well as its protein ID and translation. Therefore, a valid
    file should look something like:

    gene      1..1000
    ...
    CDS       /protein_id="Protein1"
              /translation="M..."

    Regular Expressions:
      protein
        r"CDS\s+?"          1. Find start of CDS feature
        r"(.*?)"            2. Save any location modifiers (complement, join)
        r"(\d+?)\.\."       3. Capture start position, e.g. 10..
        r"(?:.+?\.\.)*?"    4. Non-capture group, anything until .. before final
                               number in location. Optional so that simple locations
                               will also be parsed correctly.
        r"[<>]*?"           5. Account for potential truncation symbols
        r"(\d+?)"           6. Capture end position
        r"[<>)]*?"          7. Truncations, end parentheses...
        r"[\n\r]\s+?/"      8. Until next qualifier (starting with '/')
        r"(?:.+?)*?"        9. Optional extra junk if next qualifier isn't identifier

        r'(?:protein_id|locus_tag)="([\w.:-]+?)"'
                           10. Get either locus tag or protein ID, whichever is first
        r".+?"             11. Skip everything until translation
        r'/translation="([A-Z\n\r\s ]+?)"'
                           12. Get translation
    """

    patterns = {
        "scaffold": re.compile(r"LOCUS\s+?(?P<accession>\b[\w.-]+?)\s.+?//", re.DOTALL),
        "organism": re.compile(r"ORGANISM\s+?(?P<organism>\w[\w .-]+?)[\n\r]"),
        "strain": re.compile(r'/strain="(?P<strain>([\w .-]+?))"'),
        "protein": re.compile(
            r"CDS\s+?"
            r"([a-z<>(]*?)"  # join(complement(
            r"(\d+?)\.\."
            r"(?:[0-9,.()]+?\.\.)*?"
            r"[<>)]*?"
            r"(\d+?)"
            r"[<>)]*?"
            r"[\n\r]\s+?/"
            r".*?"
            r'(?:protein_id|locus_tag|gene|ID)="([\w.:-]+?)"'
            r".+?"
            r'/translation="([A-Z\n\r\s ]+?)"',
            re.DOTALL,
        ),
    }

    raw = handle.read()
    scaffolds = []
    organism, strain = None, None

    for scaffold in patterns["scaffold"].finditer(raw):

        text = scaffold.group(0)
        accession = scaffold.group("accession")

        if not organism:
            try:
                organism = patterns["organism"].search(text).groups()[0]
            except (IndexError, AttributeError):
                pass

        if not strain:
            try:
                strain = patterns["strain"].search(text).groups()[0]
            except (IndexError, AttributeError):
                pass

        proteins = [
            {
                "id": gene[3],
                "start": int(gene[1]),
                "end": int(gene[2]),
                "strand": "-" if "complement" in gene[0] else "+",
                "sequence": gene[-1].replace(" ", "").replace("\n", ""),
            }
            for gene in patterns["protein"].findall(text)
        ]

        if proteins:
            scaffolds.append({"accession": accession, "proteins": proteins})

    if not organism or not strain:
        LOG.warning("Could not find organism/strain parsing %s", handle.name)

    return {
        "name": organism,
        "strain": strain,
        "file": handle.name,
        "scaffolds": scaffolds,
    }


def get_genbank_paths(folder):
    """Generate a collection of paths to GenBank files in a specified folder."""
    if not Path(folder).is_dir():
        raise ValueError("Expected valid folder")
    valid_extensions = (".gb", ".gbk", ".genbank")
    return [
        file for file in Path(folder).iterdir() if str(file).endswith(valid_extensions)
    ]


def diamond_makedb(fasta, name):
    """Build DIAMOND database from JSON."""
    diamond = helpers.get_program_path(["diamond", "diamond-aligner"])
    subprocess.run(
        [diamond, "makedb", "--in", fasta, "--db", name],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def print_size(obj, text):
    """Calculate size (mb) of Python object and print."""
    size = sys.getsizeof(obj) / 1024 ** 2
    print(f"{text}: {size:.2f}mb")
